---
title: "Notebook 3: Metadata Analysis"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

## Getting Data

Now that we have the metadata in long form,
it's a bit easier to query it for the stuff we want.

```julia; results="hidden"
ENV["GKSwstype"] = "100"
using ECHOAnalysis
using DataFrames
using StatsPlots
using PrettyTables

rounder = Dict(0 => (v,i) -> typeof(v) <: AbstractFloat ? round(v,digits=3) : v)

@ptconfclean # clear previous configuration
@ptconf formatter = rounder nosubheader=true screen_size=(20,120)

outpath, figures = notebookpaths!(3)
allmeta = load_metadata(datatoml)
```

As an example, how many unique subjects
do we have any metadata for?

```julia
# the |> is pipe syntax, the following is the same as
# `length(unique(allmeta[:subject]))`
unique(allmeta.subject) |> length
```

(**Note**: most of these subjects have not provided fecal samples)

Or, how many subjects have at least one fecal sample?

```julia
sampleinfo = by(allmeta, :subject) do df
    df = filter(row-> row.metadatum == "CollectionRep", df)
    DataFrame(nsamples = size(df,1))
end

# remove subjects with no fecal samples
filter!(row-> row.nsamples > 0, sampleinfo)
# sort by the subject identifier
sort!(sampleinfo, :subject)
@pt randrows(sampleinfo)
```

```julia
histogram(sampleinfo.nsamples, legend=false,
    title="Samples per Subject ID",
    xlabel="# of fecal samples", ylabel="# of subjects")
```

```julia; echo=false; results="hidden"
savefig(joinpath(figures, "03-samples-per-subject.png"))
```

Wow - there are a couple of subjects that have a lot of samples.

```julia; results="hidden"
# Which subjects are those?
highsamplers = filter(row-> row.nsamples > 4, sampleinfo).subject
```
<!--Is there supposed to be a result shown here? There is not currently.-->

## Metagenomes

At this stage, what I care about are samples with metagenomes,
which are inidcated by the `DOM` metadatum.


```julia
mgxsamples = filter(allmeta) do row
        # filter on metagenomes (DOM = "Date of Metagenome")
        row.metadatum == "DOM"
    end

sort!(mgxsamples, [:sample]);
@pt mgxsamples
```

To see what samples are from those folks that gave a bunch:

```julia
highsamplers_df = filter(mgxsamples) do row
    # find rows from subjects in the highly sampled pool
    in(row.subject, highsamplers)
end

sort!(highsamplers_df, [:subject, :timepoint])

@pt highsamplers_df[!, [:sample, :subject, :timepoint]]
```

So a bunch of these are where
multiple samples were given for the same timepoint (eg `C0016_3F_1A` and `_2A`)
and/or both genotek (`3F`) and ethanol (`3E`) samples.

_Note_: after `batch006`, SOP is to send 1 `ALiquotRep` of 1 `CollectionRep` of 1 genotek sample for
each `timepoint` (i.e. only send `C0202_4F_1A` for mgx sequencing, not `C0202_4F_2A`
or `C0202_4F_1B` or `C0202_4E_1A`) unless otherwise noted.

### Unique samples

Except for later quality control,
we don't actually want to analyze replicates.
And we want to focus on only samples collected in genotek tubes,
not ethanol (so ones with an F in the second ID slot).

Using the `resolve_sampleID` function,
I can get just the relevant info for filtering on the first sample.

```julia
samples = resolve_sampleID(mgxsamples.sample)
samples[1:4]
```
```julia
seen = NamedTuple[]
usamples = NamedTuple[]

sort!(samples, lt=samplelessthan)

map(samples) do s
    # skip ethanol samples
    occursin(r"_\d+E_", s.sample) && return nothing
    subtp = (subject=s.subject, timepoint=s.timepoint)
    if !in(subtp, seen)
        push!(seen, subtp)
        push!(usamples, s)
    end
end
```
<!--What is this output meant to look like? I don't know how to interpret it as it is currently.-->

The `ECHOAnalysis` module also has [a function](https://klepac-ceraj-lab.github.io/echo_analysis/dev/metadata_handling/#ECHOAnalysis.uniquesamples-Tuple{AbstractArray{#s17,1}%20where%20#s17%3C:NamedTuple})
that does this, and has a bunch of other options too.

```julia
usamples2 = uniquesamples(samples)
@assert usamples2 == usamples
```


For simplicity later on, so I don't have to redo this,
I'll write this to a `csv` file.

```julia
using CSV
using Pkg.TOML: parsefile

# convert to dataframe
usamples = DataFrame([usamples...])
@pt usamples


CSV.write(
    joinpath(datatoml["tables"]["metadata"]["path"], "uniquesamples.csv"),
    usamples
    )
```


And we can get metadata for these samples using the `getfocusmetadata` function,
which converts the longform data into a wide table
with one row per subject/timepoint pair.
Metadata from "timpoint 0" (that is, non time-dependent data)
is added to every row for that subject.

```julia
# we don't actually need to do this here, but for future reference
usamples = CSV.read(joinpath(datatoml["tables"]["metadata"]["path"], "uniquesamples.csv"))

focus = getfocusmetadata(allmeta, resolve_sampleID.(usamples.sample))
@pt randrows(focus)
```

<!--Lines below have not been published to an html (looking at ada: home/kevin/repos/paper1_resonance/analysis/html/)-->

This can help with things like plotting.
For example, let's look at the age-adjusted cognitive scores.
First, we'll filter on kids that have cognitive scores and ages:

```julia
toplot = filter(row-> !any(ismissing, [row.cogScore, row.correctedAgeDays]), focus)
scatter(toplot.correctedAgeDays ./ 365, toplot.cogScore, group=toplot.cogAssessment,
    color=color1[2:end]', xlabel="age (years)", ylabel="Composite Score",
    title="Cognitive Assessments", legend=:bottom)
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "cogscore_age_scatter.svg"))
```

```julia
using Statistics
m = mean(toplot.cogScore)
s = std(toplot.cogScore)

toplot.zscore = map(x-> (x - m)/s, toplot.cogScore)

scatter(toplot.correctedAgeDays ./ 365, toplot.zscore,
    group = toplot.cogAssessment, color=color1[2:end]',
    ylabel = "zscore", xlabel = "age", legend=:bottom,
    title="Cognitive Assessments")
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "cogscore_zscore_age_scatter.svg"))
```
