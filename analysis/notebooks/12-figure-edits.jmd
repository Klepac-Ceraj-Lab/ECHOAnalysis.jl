---
title: "Notebook 9: Miscellaneous work to prep for paper"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

## Cohort descriptions

```julia
using ECHOAnalysis
using Microbiome
using BiobakeryUtils
using DataFrames
using Distances
using Clustering
using MultivariateStats
using Statistics
using StatsBase
using Combinatorics
using StatsPlots
using Random
using CSV

(outpath, figures) = notebookpaths!(12)
```
```julia; results="hidden"
tax = load_taxonomic_profiles()
taxfilter!(tax)

abt = abundancetable(tax)
relativeabundance!(abt)

ss = samplenames(abt)

allsamples = resolve_sampleID.(samplenames(abt))

kidsamples = uniquesamples(allsamples, samplefilter=s-> startswith(s, "C"), identifiers=[:subject])
momsamples = uniquesamples(allsamples, samplefilter=s-> startswith(s, "M"), identifiers=[:subject])
firstsamples = [kidsamples; momsamples]

firsts = view(abt, sites=getfield.(firstsamples, :sample))
kids = view(abt, sites=getfield.(kidsamples, :sample))
moms = view(abt, sites=getfield.(momsamples, :sample))

firstsmeta = load_metadata(datatoml, samples=firstsamples)
kidsmeta = load_metadata(datatoml, samples=kidssamples)
momsmeta = load_metadata(datatoml, samples=momsamples)
```


```julia
uniref_unstrat = "data/engaging/merged/batch1-10_genefamilies_relab_unstratified.tsv"
uniref_samples = samples_from_file(uniref_unstrat)
unirefs = DataFrame(:uniref=>String[], (Symbol(getfield(s, :sample))=>Float64[] for s in firstsamples)...)
keep = [[1]; findall(c-> in(c, uniref_samples), firstsamples) .+ 1 ]
for row in CSV.Rows(uniref_unstrat)
    row = view(row, keep)
    push!(unirefs, (row[1], (parse(Float64, row[i]) for i in 2:length(row))...))
end

unirefs=abundancetable(unirefs)

accessory = view(unirefs, species = [0.05 < prevalence(row, 0.) < 0.85 for row in eachrow(occurrences(unirefs))]
    )
println.(sitenames(accessory))
```

```julia; results="hidden"
taxdm = pairwise(BrayCurtis(), unique)
unirefdm = pairwise(BrayCurtis(), unirefs)
accessorydm = pairwise(BrayCurtis(), accessory)


taxmds = fit(MDS, taxdm, distances=true)
unirefmds = fit(MDS, unirefdm, distances=true)
accessorymds = fit(MDS, accessorydm, distances=true)
plot(taxmds, group = uniquemeta.ageLabel, color=color2', legend=:topright)
plot(unirefmds, group = uniquemeta.ageLabel, color=color2', legend=:bottomright )
plot(accessorymds, group = uniquemeta.ageLabel, color=color2', legend=:bottomleft)
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "accessory-genes-pcoa-agelabels.svg"))
```

```julia
scatter(projection(taxmds)[:,1],projection(accessorymds)[:,1], group = uniquemeta.ageLabel,
    color=color2', legend=:bottomright,
    xlabel="Taxonomic Profile MDS 1",
    ylabel="Functional Profile MDS 1")
```
```julia
savefig(joinpath(figures, "tax-func-mds.svg"))
```


```julia; results="hidden"
function labeldiff(dm, labels)
    u = sort(unique(labels))
    d = Dict(u1 => Dict() for u1 in u)
    for (l1 , l2) in multiset_permutations(repeat(u,2), 2)
        l1pos = findall(isequal(l1), labels)
        l2pos = findall(isequal(l2), labels)
        ds = vec(dm[l1pos, l2pos])
        d[l1][l2] = ds
    end
    d
end

taxdiffs = labeldiff(taxdm, String.(firstsmeta.ageLabel))
funcdiffs = labeldiff(unirefdm, String.(firstsmeta.ageLabel))

keypairs = multiset_permutations(repeat(sort(collect(keys(taxdiffs))),2), 2)
```
```julia
boxplot([taxdiffs[k][l] for (k, l) in keypairs], xticks = (1:length(keypairs), ["$k-$l" for (k,l) in keypairs]),
    xrotation=45, color=color2[1:4]', legend=false, ylabel="Bray Curtis dissimilarity",
    ylims=(0., 1.))
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "tax-diffs-boxplot.svg"))
```

```julia
boxplot([funcdiffs[k][l] for (k, l) in keypairs], xticks = (1:length(keypairs), ["$k-$l" for (k,l) in keypairs]),
    xrotation=45, color=color2[1:4]', legend=false, ylabel="Bray Curtis dissimilarity",
    ylims=(0., 1.))
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "func-diffs-boxplot.svg"))
```


## Cluster/permutation analysis

```julia
labels = umeta.ageLabel


dm = pairwise(BrayCurtis(), uabt, dims=2)

let notmissing = map(!ismissing, labels)
    global dm = dm[notmissing, notmissing]
    global labels = collect(skipmissing(labels))
end

function meandistances(labels, dm, check=unique(labels))
    indicies = Dict(l => findall(labels .== l) for l in check)
    n = length(check)
    dists = ones(Float64, n, n)
    for i in 1:n, j in 1:n
        if i == j
            m = mean(dm[k, l] for k in indicies[check[i]], l in indicies[check[j]] if k != l)
            dists[i, j] = m
        elseif i < j
            m = mean(dm[k, l] for k in indicies[check[i]], l in indicies[check[j]])
            dists[i, j] = m
            dists[j, i] = m
        end
    end
    return dists
end

function permutation_test(labels, dm; nperms=1000)
    return cat(map(1:nperms) do _
        newlabels = shuffle(labels)
        meandistances(newlabels, dm)
        end..., dims=3)
end


d = meandistances(labels, dm)
pt = permutation_test(labels, dm, nperms=5000)
ls = unique(labels)
sum(x-> x > d[2,4], pt[2,4,:])

using StatsPlots

plot(let myplots = []
    for i in 1:size(d, 1), j in 1:size(d, 1)
        h = histogram(pt[i,j,:], label = "distribution")
         plot!([(d[i,j], 0), (d[i,j], 600)], label = "true value")
        title!("$(ls[i]) vs $(ls[j])")
        xaxis!(0.:0.05:1)

        push!(myplots, h)
    end
    myplots
end..., size=(1200,1200), legend=false)


savefig(joinpath(figures, "all-distances.svg"))
```

```julia
using MultivariateStats
mds = fit(MDS, dm, distances=true)

plot(mds, group=labels, color=color3')
title!("Unique samples age groups")
savefig(joinpath(figures, "age-groups-pcoa.svg"))
```


## Maaslin2 heatmaps

```julia
results = let
    results = DataFrame(metadata=String[], feature=String[],
                        value=Float64[], coef=Float64[], stderr=Float64[],
                        N=Int[], not_zero=Int[], pval=Float64[], qval=Float64[], model=String[], kind=String[])
    headers = names(results)
    for (root, dirs, files) in walkdir("data/notebooks")
        filter!(f-> f == "all_results.tsv", files)
        length(files) > 0 || continue
        df = CSV.read(joinpath(root, files[1]))
        (kind, model) = split(basename(root), "__")
        df[!, :model] = model
        df[!, :kind] = kind
        names!(df, headers)
        append!(results, df)
    end
    results
end

filter!(row-> row.qval < 0.1, results)


```
