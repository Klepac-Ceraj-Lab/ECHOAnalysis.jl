ecs---
title: "Notebook 8: Functional Profiles"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

Now we've been through some analyses of the taxonomic profiles,
but metagenomes *also* allow the generation of functional profiles;
that is, what genes are present in a given community.

These profiles were generated with [HUMANn2](http://huttenhower.sph.harvard.edu/humann2).

```julia; echo=false; results="hidden"
using ECHOAnalysis
using Microbiome
using BiobakeryUtils
using StatsPlots
using DataFrames
using Distances
using PrettyTables
using CSV

rounder = Dict(0 => (v,i) -> typeof(v) <: AbstractFloat ? round(v,digits=3) : v)
@ptconfclean # clear previous configuration
@ptconf formatter = rounder nosubheader=true screen_size=(20,120)

(outpath, figures) = notebookpaths!(8)
```

## Kegg Orthology functions

```julia; results="hidden"
kos = CSV.read("data/engaging/merged/batch1-10_kos_names.csv")
names!(kos, map(n-> Symbol(resolve_sampleID(replace(String(n), "_Abundance-RPKs"=>"")).sample), names(kos)))
# ~ 5% prevalence filter
kos = kos[map(row-> sum(x-> x > 0, row[Not(1)]) > ncol(kos) * .05, eachrow(kos)), :]
kos = abundancetable(kos)
relativeabundance!(kos)
```

```julia
allsamples = resolve_sampleID.(samplenames(kos))
uabt = view(kos, sites=getfield.(uniquesamples(allsamples, takefirst=true), :sample))
usamples = resolve_sampleID.(samplenames(uabt))
umeta = load_metadata(datatoml, samples=usamples)

kidssamples = uniquesamples(allsamples,
                    samplefilter=s-> startswith(s, "C"),
                    takefirst=true, identifiers=[:subject])
momsamples = uniquesamples(allsamples,
                    samplefilter=s-> startswith(s, "M"),
                    takefirst=true, identifiers=[:subject])


kids = view(kos, sites=getfield.(kidssamples, :sample))
moms = view(kos, sites=getfield.(momsamples, :sample))

kidsmeta = load_metadata(datatoml, samples=kidssamples)
momsmeta = load_metadata(datatoml, samples=momsamples)

```
```julia
using StatsPlots
using MultivariateStats

udm = pairwise(BrayCurtis(), uabt, dims=2)

labels = map(eachrow(umeta)) do row
    age = row[:correctedAgeDays] / 365
    if startswith(row[:sample], "C")
        if !ismissing(age)
            if age <= 1
                return "1 and under"
            elseif age <= 2
                return "1 to 2"
            else
                return "2 and over"
            end
        else
            return missing
        end
    elseif startswith(row[:sample], "M")
        return "mom"
    else
        return missing
    end
end

notmissing = .!ismissing.(labels)

nmumds = fit(MDS, udm[notmissing, notmissing], distances=true)
plot(nmumds, group=String.(labels[notmissing]), legend=:bottomleft)
title!("Functional Profiles (KOs)")
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "kos_unique_pcoa.svg"))
```



```julia
udm = pairwise(BrayCurtis(), uabt, dims=2)
perm = permanova(udm, [startswith(s, "M") ? "mom" : "kid" for s in samplenames(uabt)])
perm[!,:feature] .= "kos"
perm[!,:variable] .= "Subject Type"
```

```julia
kids_dm = pairwise(BrayCurtis(), kids, dims=2)

p = permanova(kids_dm, kidsmeta.correctedAgeDays, filter=.!ismissing.(kidsmeta.correctedAgeDays))
p[!,:feature] .= "kos"
p[!, :variable] .= "Age"
perm = vcat(perm, p)

kidsmeta.birthType = Vector{Union{Missing,String}}(kidsmeta.birthType)
p = permanova(kids_dm, kidsmeta.birthType, filter=.!ismissing.(kidsmeta.birthType))
p[!,:feature] .= "kos"
p[!, :variable] .= "birthType"
perm = vcat(perm, p)

kidsmeta[!, :breastfed] = breastfeeding.(eachrow(kidsmeta))
p = permanova(kids_dm, kidsmeta.breastfed)
p[!,:feature] .= "kos"
p[!, :variable] .= "breastfed"
perm = vcat(perm, p)

kidsmeta.formulafed = formulafeeding.(eachrow(kidsmeta))
p = permanova(kids_dm, kidsmeta.formulafed)
p[!,:feature] .= "kos"
p[!, :variable] .= "formulafed"
perm = vcat(perm, p)

kidsmeta.childGender = Vector{Union{Missing,String}}(kidsmeta.childGender)
p = permanova(kids_dm, kidsmeta.childGender, filter=.!ismissing.(kidsmeta.childGender))
p[!,:feature] .= "kos"
p[!, :variable] .= "childGender"
perm = vcat(perm, p)

p = permanova(kids_dm, kidsmeta.mother_HHS, filter=.!ismissing.(kidsmeta.mother_HHS))
p[!,:feature] .= "kos"
p[!, :variable] .= "mother_HHS"
perm = vcat(perm, p)
filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm
```

### Young kids

```julia; results="hidden"
# get kids that are less than 1.5 years old
young = map(a-> !ismissing(a) && a <= 365*1.5, kidsmeta.correctedAgeDays)
youngkids = view(kids, sites=young)

# make new distance matrix
youngkids_dm = pairwise(BrayCurtis(), youngkids, dims=2,)
youngkidsmeta = kidsmeta[young, :]

# Test breasfeeding and formula feeding
p = permanova(youngkids_dm, youngkidsmeta.breastfed, 10000)
p[!, :feature] .= "kos"
p[!, :variable] .= "young kids breastfed"
perm = vcat(perm, p)

p = permanova(youngkids_dm, youngkidsmeta.formulafed, 10000)
p[!, :feature] .= "kos"
p[!, :variable] .= "young kids formulafed"
perm = vcat(perm, p)

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm
```

```julia
using RCall

filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:white_matter_volume]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :white_matter_volume]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ white_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]

p[!,:feature] .= "kos"
p[!, :variable] .= "white_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## grey matter
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:grey_matter_volume]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :grey_matter_volume]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ grey_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "kos"
p[!, :variable] .= "grey_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## CSF
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:csf_volume]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :csf_volume]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ csf_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "kos"
p[!, :variable] .= "csf_volume"
perm = vcat(perm, p[[2],:])
```
```julia
## Cognitive Assessment

using Statistics
# Bayleys doesn't have a compositve score calculated, but we can get it:
kidsmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(kidsmeta))

kidsmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(kidsmeta,1))
kidsmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(kidsmeta,1))

map(enumerate(eachrow(kidsmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        kidsmeta[i, :cogAssessment] = assessment
        kidsmeta[i, :cogScore] = cogs[col[1]]
    end
end

p = permanova(kids_dm, kidsmeta.cogScore, filter=.!ismissing.(kidsmeta.cogScore))
p[!,:feature] .= "kos"
p[!, :variable] .= "cogScore"
perm = vcat(perm, p);
```


```julia
okids = view(kids, sites=map(s-> !ismissing(s) && s > 365*2, kidsmeta.correctedAgeDays))
okidsmeta = view(kidsmeta, map(s-> !ismissing(s) && s > 365*2, kidsmeta.correctedAgeDays), :)
okids_dm = pairwise(BrayCurtis(), okids)

p = permanova(okids_dm, okidsmeta.cogScore, filter=.!ismissing.(okidsmeta.cogScore))
p[!,:feature] .= "kos"
p[!, :variable] .= "old kids cogScore"
perm = vcat(perm, p)

p = permanova(okids_dm, okidsmeta.csf_volume, filter=.!ismissing.(okidsmeta.csf_volume))
p[!,:feature] .= "kos"
p[!, :variable] .= "old kids csf_volume"
perm = vcat(perm, p)

p = permanova(okids_dm, okidsmeta.grey_matter_volume, filter=.!ismissing.(okidsmeta.grey_matter_volume))
p[!,:feature] .= "kos"
p[!, :variable] .= "old kids grey_matter_volume"
perm = vcat(perm, p)

p = permanova(okids_dm, okidsmeta.white_matter_volume, filter=.!ismissing.(okidsmeta.white_matter_volume))
p[!,:feature] .= "kos"
p[!, :variable] .= "old kids white_matter_volume"
perm = vcat(perm, p)
filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm[end-5:end,:]
```


```julia
using MultipleTesting

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)

perm.p_value = Float64.(perm[Symbol("Pr(>F)")])
perm.q_value = adjust(perm.p_value, BenjaminiHochberg())
sort!(perm, :q_value)

# reorder columns
perm = perm[:,[:feature, :variable, :R2, :p_value, :q_value]]
CSV.write(joinpath(outpath, "genefamilies_permanovas.csv"), perm)
```

```julia
using StatsPlots

sort!(perm, [:R2])

bar(perm.R2 .* 100,
    xticks=(1:(size(perm,1)-1), perm.variable),
    xrotation=45, color=:grey)

for i in eachindex(perm.R2)
    r2 = perm[i, :R2] * 100
    q = perm[i, :q_value]
    kind = perm.variable
    if q > 0.05
        continue
    elseif q > 0.01
        stars = "*"
    elseif q > .001
        stars = "**"
    else
        stars = "***"
    end
    annotate!(i, r2+.1, text(stars, :center))
end

plot!(legend=false, title="Function Profiles (kos) PERMANOVA",
    ylabel="% Variance explainable")
```

```julia
savefig(joinpath(figures, "kos_permanovas.svg"))
```

## Enzyme Classes

```julia
allsamples = resolve_sampleID.(samplenames(ecs))
uabt = view(ecs, sites=getfield.(uniquesamples(allsamples, takefirst=true), :sample))
usamples = resolve_sampleID.(samplenames(uabt))
umeta = load_metadata(datatoml, samples=usamples)

kidssamples = uniquesamples(allsamples,
                    samplefilter=s-> startswith(s, "C"),
                    takefirst=true, identifiers=[:subject])
momsamples = uniquesamples(allsamples,
                    samplefilter=s-> startswith(s, "M"),
                    takefirst=true, identifiers=[:subject])


kids = view(ecs, sites=getfield.(kidssamples, :sample))
moms = view(ecs, sites=getfield.(momsamples, :sample))

kidsmeta = load_metadata(datatoml, samples=kidssamples)
momsmeta = load_metadata(datatoml, samples=momsamples)

```
```julia
using StatsPlots
using MultivariateStats

udm = pairwise(BrayCurtis(), uabt, dims=2)

labels = map(eachrow(umeta)) do row
    age = row[:correctedAgeDays] / 365
    if startswith(row[:sample], "C")
        if !ismissing(age)
            if age <= 1
                return "1 and under"
            elseif age <= 2
                return "1 to 2"
            else
                return "2 and over"
            end
        else
            return missing
        end
    elseif startswith(row[:sample], "M")
        return "mom"
    else
        return missing
    end
end

notmissing = .!ismissing.(labels)

nmumds = fit(MDS, udm[notmissing, notmissing], distances=true)
plot(nmumds, group=String.(labels[notmissing]), legend=:bottomleft)
title!("Functional Profiles (ecs)")
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "ecs_unique_pcoa.svg"))
```



```julia
udm = pairwise(BrayCurtis(), uabt, dims=2)
perm = permanova(udm, [startswith(s, "M") ? "mom" : "kid" for s in samplenames(uabt)])
perm[!,:feature] .= "ecs"
perm[!,:variable] .= "Subject Type"
```

```julia
kids_dm = pairwise(BrayCurtis(), kids, dims=2)

p = permanova(kids_dm, kidsmeta.correctedAgeDays, filter=.!ismissing.(kidsmeta.correctedAgeDays))
p[!,:feature] .= "ecs"
p[!, :variable] .= "Age"
perm = vcat(perm, p)

kidsmeta.birthType = Vector{Union{Missing,String}}(kidsmeta.birthType)
p = permanova(kids_dm, kidsmeta.birthType, filter=.!ismissing.(kidsmeta.birthType))
p[!,:feature] .= "ecs"
p[!, :variable] .= "birthType"
perm = vcat(perm, p)

kidsmeta[!, :breastfed] = breastfeeding.(eachrow(kidsmeta))
p = permanova(kids_dm, kidsmeta.breastfed)
p[!,:feature] .= "ecs"
p[!, :variable] .= "breastfed"
perm = vcat(perm, p)

kidsmeta.formulafed = formulafeeding.(eachrow(kidsmeta))
p = permanova(kids_dm, kidsmeta.formulafed)
p[!,:feature] .= "ecs"
p[!, :variable] .= "formulafed"
perm = vcat(perm, p)

kidsmeta.childGender = Vector{Union{Missing,String}}(kidsmeta.childGender)
p = permanova(kids_dm, kidsmeta.childGender, filter=.!ismissing.(kidsmeta.childGender))
p[!,:feature] .= "ecs"
p[!, :variable] .= "childGender"
perm = vcat(perm, p)

p = permanova(kids_dm, kidsmeta.mother_HHS, filter=.!ismissing.(kidsmeta.mother_HHS))
p[!,:feature] .= "ecs"
p[!, :variable] .= "mother_HHS"
perm = vcat(perm, p)
filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm
```

### Young kids

```julia; results="hidden"
# get kids that are less than 1.5 years old
young = map(a-> !ismissing(a) && a <= 365*1.5, kidsmeta.correctedAgeDays)
youngkids = view(kids, sites=young)

# make new distance matrix
youngkids_dm = pairwise(BrayCurtis(), youngkids, dims=2,)
youngkidsmeta = kidsmeta[young, :]

# Test breasfeeding and formula feeding
p = permanova(youngkids_dm, youngkidsmeta.breastfed, 10000)
p[!, :feature] .= "ecs"
p[!, :variable] .= "young kids breastfed"
perm = vcat(perm, p)

p = permanova(youngkids_dm, youngkidsmeta.formulafed, 10000)
p[!, :feature] .= "ecs"
p[!, :variable] .= "young kids formulafed"
perm = vcat(perm, p)

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm
```

```julia
using RCall

filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:white_matter_volume]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :white_matter_volume]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ white_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]

p[!,:feature] .= "ecs"
p[!, :variable] .= "white_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## grey matter
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:grey_matter_volume]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :grey_matter_volume]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ grey_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "ecs"
p[!, :variable] .= "grey_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## CSF
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:csf_volume]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :csf_volume]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ csf_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "ecs"
p[!, :variable] .= "csf_volume"
perm = vcat(perm, p[[2],:])
```
```julia
## Cognitive Assessment

using Statistics
# Bayleys doesn't have a compositve score calculated, but we can get it:
kidsmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(kidsmeta))

kidsmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(kidsmeta,1))
kidsmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(kidsmeta,1))

map(enumerate(eachrow(kidsmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        kidsmeta[i, :cogAssessment] = assessment
        kidsmeta[i, :cogScore] = cogs[col[1]]
    end
end

p = permanova(kids_dm, kidsmeta.cogScore, filter=.!ismissing.(kidsmeta.cogScore))
p[!,:feature] .= "ecs"
p[!, :variable] .= "cogScore"
perm = vcat(perm, p);
```


```julia
okids = view(kids, sites=map(s-> !ismissing(s) && s > 365*2, kidsmeta.correctedAgeDays))
okidsmeta = view(kidsmeta, map(s-> !ismissing(s) && s > 365*2, kidsmeta.correctedAgeDays), :)
okids_dm = pairwise(BrayCurtis(), okids)

p = permanova(okids_dm, okidsmeta.cogScore, filter=.!ismissing.(okidsmeta.cogScore))
p[!,:feature] .= "ecs"
p[!, :variable] .= "old kids cogScore"
perm = vcat(perm, p)

p = permanova(okids_dm, okidsmeta.csf_volume, filter=.!ismissing.(okidsmeta.csf_volume))
p[!,:feature] .= "ecs"
p[!, :variable] .= "old kids csf_volume"
perm = vcat(perm, p)

p = permanova(okids_dm, okidsmeta.grey_matter_volume, filter=.!ismissing.(okidsmeta.grey_matter_volume))
p[!,:feature] .= "ecs"
p[!, :variable] .= "old kids grey_matter_volume"
perm = vcat(perm, p)

p = permanova(okids_dm, okidsmeta.white_matter_volume, filter=.!ismissing.(okidsmeta.white_matter_volume))
p[!,:feature] .= "ecs"
p[!, :variable] .= "old kids white_matter_volume"
perm = vcat(perm, p)
filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm[end-5:end,:]
```


```julia
using MultipleTesting

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)

perm.p_value = Float64.(perm[Symbol("Pr(>F)")])
perm.q_value = adjust(perm.p_value, BenjaminiHochberg())
sort!(perm, :q_value)

# reorder columns
perm = perm[:,[:feature, :variable, :R2, :p_value, :q_value]]
CSV.write(joinpath(outpath, "genefamilies_permanovas.csv"), perm)
```

```julia
using StatsPlots

sort!(perm, [:R2])

bar(perm.R2 .* 100,
    xticks=(1:(size(perm,1)-1), perm.variable),
    xrotation=45, color=:grey)

for i in eachindex(perm.R2)
    r2 = perm[i, :R2] * 100
    q = perm[i, :q_value]
    kind = perm.variable
    if q > 0.05
        continue
    elseif q > 0.01
        stars = "*"
    elseif q > .001
        stars = "**"
    else
        stars = "***"
    end
    annotate!(i, r2+.1, text(stars, :center))
end

plot!(legend=false, title="Function Profiles (ecs) PERMANOVA",
    ylabel="% Variance explainable")
```

```julia
savefig(joinpath(figures, "ecs_permanovas.svg"))
```

### Linear Models

Because there are so many gene functions,
we'll do some agressive filtering for
prevalence and abundance.

```julia
allsamples = resolve_sampleID.(samplenames(kos))
uabt = view(kos, sites=getfield.(uniquesamples(allsamples, takefirst=true), :sample))
usamples = resolve_sampleID.(samplenames(uabt))
umeta = load_metadata(datatoml, samples=usamples)

kidssamples = uniquesamples(allsamples,
                    samplefilter=s-> startswith(s, "C"),
                    takefirst=true, identifiers=[:subject])
momsamples = uniquesamples(allsamples,
                    samplefilter=s-> startswith(s, "M"),
                    takefirst=true, identifiers=[:subject])


kids = view(kos, sites=getfield.(kidssamples, :sample))
moms = view(kos, sites=getfield.(momsamples, :sample))

kidsmeta = load_metadata(datatoml, samples=kidssamples)
momsmeta = load_metadata(datatoml, samples=momsamples)

```

```julia
prevfilt = let occ = occurrences(kids)
    # at least 5% of samples have at least 0.0001% abundance
    [prevalence(occ[i, :], 1e-6) > 0.05 for i in 1:size(occ, 1)]
end

prev = view(kids, species=prevfilt)

kodf = DataFrame(EC=featurenames(prev))

let occ = occurrences(prev)
    for (i, sample) in enumerate(samplenames(prev))
        ismissing(kidsmeta[i, :birthType]) && continue
        # Make a column for each sample
        kodf[!, Symbol(sample)] = occ[:, i]
    end
end

kodf[!,1] = map(s-> replace(s, r"[^\w]"=>"."), kodf[!,1])
```

```julia
kidsmeta.breastfed = breastfeeding.(eachrow(kidsmeta))
kidsmeta.formulafed = formulafeeding.(eachrow(kidsmeta))

# view() does not create a new dataframe, but allows us to subset it.
covariatedf = view(kidsmeta, :, [:sample, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])

# Maaslin2 also wants tab separated values
CSV.write(joinpath(outpath, "kids_kos_abundance.tsv"), delim='\t', kodf)
CSV.write(joinpath(outpath, "kids_covariates.tsv"), delim='\t', covariatedf)

@pt covariatedf
```

Now, we'll run `Maaslin2` using `RCall.jl`.
You need to have `Maaslin2` installed for this to work - [see here](https://bitbucket.org/biobakery/maaslin2/src/default/#markdown-header-installation)

```julia; results="hidden"
using RCall

R"library(Maaslin2)"
let version = R"packageVersion('Maaslin2')"
    println(version)
end
```

```julia; results="hidden"
# Model: species abundance ~ age + mother_HHS + breastfed + birthType

R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_ko_abundance.tsv")),
            $(joinpath(outpath, "kids_covariates.tsv")),
            $(joinpath(outpath, "ko__age_ses_bf_birth")))
"""
```
```julia
# view() does not create a new dataframe, but allows us to subset it.
whitematterdf = view(kidsmeta, :, [:sample, :white_matter_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])

# Maaslin2 also wants tab separated values
CSV.write(joinpath(outpath, "kids_white_matter.tsv"), delim='\t', whitematterdf)
```

Now, we'll run Maaslin2.
You need to have Maaslin2 installed for this to work - [see here](https://bitbucket.org/biobakery/maaslin2/src/default/#markdown-header-installation)

```julia
using RCall

R"library(Maaslin2)"
let version = R"packageVersion('Maaslin2')"
    @show version
end;
```

```julia; results="hidden"
R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_ko_abundance.tsv")),
            $(joinpath(outpath, "kids_white_matter.tsv")),
            $(joinpath(outpath, "ko__wm_age_ses_bf_birth")))
"""
```

We can do this with some other brain data as well:


```julia; results="hidden"
greymatterdf = view(kidsmeta, :, [:sample, :grey_matter_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_grey_matter.tsv"), delim='\t', greymatterdf)

R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_ko_abundance.tsv")),
            $(joinpath(outpath, "kids_grey_matter.tsv")),
            $(joinpath(outpath, "ko__gm_age_ses_bf_birth")))
"""

csfdf = view(kidsmeta, :, [:sample, :csf_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_csf.tsv"), delim='\t', csfdf)

R"""
fit_data <- Maaslin2(
             $(joinpath(outpath, "kids_ko_abundance.tsv")),
             $(joinpath(outpath, "kids_csf.tsv")),
             $(joinpath(outpath, "ko__csf_age_ses_bf_birth")))
""";
```

#### Cognitive Assessments


```julia
using Statistics
# Bayleys doesn't have a compositve score calculated, but we can get it:
kidsmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(kidsmeta))

kidsmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(kidsmeta,1))
kidsmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(kidsmeta,1))

map(enumerate(eachrow(kidsmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        kidsmeta[i, :cogAssessment] = assessment
        kidsmeta[i, :cogScore] = cogs[col[1]]
    end
end
```

```julia; results="hidden"
cogdf = view(kidsmeta, :, [:sample, :cogScore, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_cog.tsv"), delim='\t', cogdf)

R"""
Maaslin2(
     $(joinpath(outpath, "kids_ko_abundance.tsv")),
     $(joinpath(outpath, "kids_cog.tsv")),
     $(joinpath(outpath, "ec__cog_age_ses_bf_birth")))
""";

```
