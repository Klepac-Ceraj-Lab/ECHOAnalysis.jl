---
title: "Notebook 11: Additional Functional Profiles Analysis with Biobakery"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

Let's do some additional analysis of the functional profiles
started in notebook 8.

```julia; echo=false; results="hidden"
using ECHOAnalysis
using Microbiome
using BiobakeryUtils
using StatsPlots
using DataFrames
using Distances
using CSV

(outpath, figures) = notebookpaths!(11)
```

## Humann2 function plots

HUMANn2 provides a convenience script for plotting functional profiles,
but it requires an annotated table (`pcl` format),
where metadata comes before bug abundances.

```julia
kos = CSV.read("data/engaging/merged/batch1-10_kos_names.csv")
names!(kos, map(n-> Symbol(resolve_sampleID(replace(String(n), "_Abundance-RPKs"=>"")).sample), names(kos)))
# ~ 5% prevalence filter
kos = kos[map(row-> sum(x-> x > 0, row[Not(1)]) > ncol(kos) * .05, eachrow(kos)), :]
# this provides metadata in wide form
kosmeta = load_metadata(datatoml; samples=resolve_sampleID.(names(kos[!,Not(1)])))

notmissing = .!ismissing.(kosmeta.ageLabel)
# get samples where age is known (first `true` is to get ec column)
kos = kos[!,[true, notmissing...]]
kosmeta = kosmeta[notmissing, :]

# to get metadata in same order as kos table
function transposedf(df)
    ns = names(df)
    dft = DataFrame(ns[1]=>ns[2:end])
    for (i, n) in enumerate(df[!,1])
        dft[!, Symbol(n)] = Vector(df[i,Not(1)])
    end
    return dft
end


CSV.write(joinpath(outpath, "annotated_kos.pcl"), transposedf(kosmeta[!,[:sample, :ageLabel]]), delim='\t')
CSV.write(joinpath(outpath, "annotated_kos.pcl"), kos, append=true, delim='\t')
open(joinpath(outpath, "kos.txt"), "w") do io
    for ec in kos[:,1]
        write(io, ec, '\n')
    end
end

isdir(joinpath(outpath, "humann2_barplots")) || mkdir(joinpath(outpath, "humann2_barplots"))
```

```julia
nostrat = CSV.read("data/engaging/merged/batch1-10_kos_names.csv")

prev = map(row-> prevalence(collect(row[2:end]), 0.), eachrow(nostrat))
describe(prev)
```

```julia
using Statistics
using MultivariateStats

accessory = nostrat[prev .< quantile(prev, 0.75), :]
names(accessory)
names!(accessory, map(n-> replace(replace(String(n), r"_S\d+_Abundance-RPKs"=>""), "-"=>"_") |> Symbol, names(accessory)))
aabt = abundancetable(accessory)
accsamples = resolve_sampleID.(samplenames(aabt))
au = view(aabt, sites=getfield.(uniquesamples(accsamples, takefirst=true), :sample))

tax = load_taxonomic_profiles()
taxfilter!(tax)
taxabt = abundancetable(tax)
relativeabundance!(taxabt)
taxsamples = resolve_sampleID.(samplenames(taxabt))
tu = view(taxabt, sites=getfield.(uniquesamples(taxsamples, takefirst=true), :sample))

overlap = intersect(samplenames(tu),samplenames(au))

oau = view(au, sites=overlap)
otu = view(tu, sites=overlap)

ometa = load_metadata(datatoml; samples=resolve_sampleID.(samplenames(oau)))

notmissing = .!ismissing.(ometa.ageLabel)
oaunm = view(oau, sites=notmissing)
otunm = view(otu, sites=notmissing)
ometanm = view(ometa, notmissing, :)

oadm = pairwise(BrayCurtis(), oaunm)
oamds = fit(MDS, oadm, distances=true)

otdm = pairwise(BrayCurtis(), otunm)
otmds = fit(MDS, otdm, distances=true)
```

```julia
filter!(row-> in(row.Sample, samplenames(otunm)), qc)
by(qc, [:Sample]) do df
    if nrow(df) >1
        @info df
    end
end
unique!(qc, :Sample)
sort!(qc, :Sample)
wqc = map(x-> in(x, qc.Sample), samplenames(otunm))

α = shannon(view(otunm, sites=wqc))
describe(log.(qc.trimmed ./ α))
scatter(projection(oamds)[wqc, 1], projection(otmds)[wqc, 1],
        zcolor=log.(qc.trimmed ./ α),
        xlabel="Function MDS1", ylabel="Taxonomy MDS1")


df = DataFrame(taxmds1=projection(otmds)[wqc, 1],
                funcmds1=projection(oamds)[wqc, 1],
                shannon=α,
                trimmed=qc.trimmed)
df.pos = df.funcmds1 .< -0.025
@df df boxplot(:pos, log.(qc.trimmed ./ α))

wqcmeta = load_metadata(datatoml, samples=resolve_sampleID(samplenames(otunm)[wqc]))
wqcnm = .!ismissing.(wqcmeta.mother_HHS)

scatter(projection(oamds)[wqc, 1][wqcnm], projection(otmds)[wqc, 1][wqcnm],
        zcolor=wqcmeta.mother_HHS[wqcnm],
        xlabel="Function MDS1", ylabel="Taxonomy MDS1")

scatter(projection(oamds)[wqc, 1][wqcnm], wqcmeta.mother_HHS[wqcnm])


```
```julia
savefig(joinpath(outpath, "ko-tax-mds1-ageLabel.svg"))
```

```julia
scatter(ometanm.correctedAgeDays ./365, projection(oamds)[:, 1],
    group = ometanm.ageLabel, xaxis=:flip, legend=false,
    ylabel="MDS1", xlabel="Age (years)",
    title = "Accessory KOs over time")
```
```julia
savefig(joinpath(outpath, "ko-mds1-age-kids.svg"))
```

```julia
let nm = .!ismissing.(ometanm.correctedAgeDays)
    scatter(projection(oamds)[nm, 1], projection(otmds)[nm, 1],
        zcolor=log.(ometanm.correctedAgeDays[nm]), legend=false,
        xlabel="Function MDS1", ylabel="Taxonomy MDS1", title="Taxonomy and Functions in Kids",
        color=:plasma)
end
```
```julia
savefig(joinpath(outpath, "ko-tax-mds1-age.svg"))
```


```julia
cor(projection(oamds)[:, 1], projection(otmds)[:, 1])
```

## Brain KOs

```julia
brainkos = Set(String[])
for line in eachline("/lovelace/echo/analysis/gutbrain/GBMs/GBM.inputfile.txt")
    for m in eachmatch(r"K\d+", line)
        push!(brainkos, String(m.match))
    end
end

brainkos
```
```julia
names!(nostrat, map(n-> replace(replace(String(n), r"_S\d+_kneaddata.+$"=>""), "-"=>"_") |> Symbol, names(nostrat)))
nsabt = abundancetable(nostrat)
relativeabundance!(nsabt)
bkosabt = view(nsabt, species=map(ko-> any(b-> occursin(b, ko), brainkos), nostrat[!, 1]),
                        sites=getfield.(uniquesamples(resolve_sampleID.(samplenames(nsabt)),takefirst=true), :sample)
                        )
bkodm = pairwise(BrayCurtis(), bkosabt)
bkorowdm = pairwise(BrayCurtis(), bkosabt, dims=1)
bkorowdm = map(x-> isnan(x) ? 1. : x, bkorowdm)

bkomds = fit(MDS, bkodm, distances=true)

using Clustering
bkohcl = hclust(bkodm, linkage=:average, branchorder=:optimal)
bkorowhcl = hclust(bkorowdm, linkage=:average, branchorder=:optimal)
heatmap(asin.(sqrt.(occurrences(bkosabt)))[bkorowhcl.order, bkohcl.order], color=:PuBu)
using MicrobiomePlots

bkometa = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(bkosabt)))
bkometa[!, :ageLabel] = map(eachrow(bkometa)) do row
    age = row[:correctedAgeDays] / 365
    if startswith(row[:sample], "C")
        if !ismissing(age)
            if age <= 1
                return "1au"
            elseif age <= 2
                return "1to2"
            else
                return "gt2"
            end
        else
            return missing
        end
    elseif startswith(row[:sample], "M")
        return "mom"
    else
        return missing
    end
end

heatmap(asin.(sqrt.(occurrences(bkosabt)))[bkorowhcl.order, bkohcl.order], color=:PuBu)

plot(
    heatmap(asin.(sqrt.(occurrences(bkosabt)))[bkorowhcl.order, bkohcl.order], color=:PuBu),
    plot(annotationbar([ismissing(x) ? "missing" : x for x in bkometa.ageLabel],
        Dict("1au"=>color2[1], "1to2"=>color2[2], "gt2"=>color2[3], "mom"=>color2[4], "missing"=>color2[end]))),
    layout=grid(2,1, heights=[0.9, 0.1]))
```
```julia
savefig(joinpath(outpath, "brainkos-heatmap.svg"))
```

```julia
plot(bkohcl)
```

```julia
## Cognitive Assessment

using Statistics
# Bayleys doesn't have a compositve score calculated, but we can get it:
bkometa.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(bkometa))

# pre-fill columns for numerical score and name of the measurement test
bkometa.cogScore = Vector{Union{Float64,Missing}}(missing, size(bkometa,1))
bkometa.cogAssessment = Vector{Union{String,Missing}}(missing, size(bkometa,1))

map(enumerate(eachrow(bkometa))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        bkometa[i, :cogAssessment] = assessment
        bkometa[i, :cogScore] = cogs[col[1]]
    end
end


filt = map(eachrow(bkometa)) do row
    !ismissing(row.cogScore) && row.correctedAgeDays > 365 * 2
end


permanova(bkodm[filt,filt], bkometa.cogScore[filt])
```
