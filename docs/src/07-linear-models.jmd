---
title: "Notebook 7: Linear Models"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

Now that we've done omnibus tests,
it's time to look at per-feature tests with multivariate linear models.

```julia; echo=false; results="hidden"
ENV["GKSwstype"] = "100"

using ECHOAnalysis
using DataFrames
using PrettyTables
using Statistics
using Distances
using Microbiome
using MultivariateStats
using StatsPlots
using MicrobiomePlots
using BiobakeryUtils
using Clustering
using CSV

rounder = Dict(0 => (v,i) -> typeof(v) <: AbstractFloat ? round(v,digits=3) : v)
@ptconf formatter = rounder nosubheader=true screen_size=(20,120)

outpath, figures = notebookpaths!(7)
```

```julia
tax = load_taxonomic_profiles()
taxfilter!(tax, :species)
abt = abundancetable(tax)
relativeabundance!(abt)
kids_abt = view(abt, sites=firstkids(samplenames(abt)))

focusmeta = load_metadata(datatoml,
                samples=resolve_sampleID.(samplenames(kids_abt))
                )
@pt focusmeta
```

First, we'll use `Maaslin2` from the Huttenhower lab.
To do this, we need to first save the abundance table
and the metadata we want to include in the model.
The abundance table will have features (species) as rows and samples as columns,
while the metadata will have features (metadata) as columns and samples as rows.

All of our models will take the form

```
species abundance ~ {Brain data} + age + mother_HHS + breastfed + birthType
```

Where `{Brain data}` is a brain volume measure or cognitive score.

`Maaslin2` doesn't play nice with missing categorical data,
so I'll manually remove samples that don't have `birthType` information

```julia
species = DataFrame(species=speciesnames(kids_abt))

let occ = occurrences(kids_abt)
    for (i, sample) in enumerate(samplenames(kids_abt))
        ismissing(focusmeta[i, :birthType]) && continue
        # Make a column for each sample
        species[!,Symbol(sample)] = occ[:, i]
    end
end
```

In addition, we want the brain volumes to be normalized
by the total brain volume.

```julia; results="hidden"
focusmeta.brain_volume = map(row-> sum(row[[:csf_volume, :white_matter_volume, :grey_matter_volume]]), eachrow(focusmeta))
focusmeta.csf_volume = focusmeta.csf_volume ./ focusmeta.brain_volume
focusmeta.white_matter_volume = focusmeta.white_matter_volume ./ focusmeta.brain_volume
focusmeta.grey_matter_volume = focusmeta.grey_matter_volume ./ focusmeta.brain_volume
```

Now we'll subset the metadata `DataFrame` to include a subset of the metadata.
First, we'll fit a linear model with no brain measurements.

```julia
# add a sample id column
focusmeta.sample = collect(samplenames(kids_abt))
focusmeta.breastfed = map(breastfeeding, eachrow(focusmeta))
dropmissing!(focusmeta, :birthType)

# view() does not create a new dataframe, but allows us to subset it.
covariatedf = view(focusmeta, :, [:sample, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])

# Maaslin2 also wants tab separated values
CSV.write(joinpath(outpath, "kids_species_abundance.tsv"), delim='\t', species)
CSV.write(joinpath(outpath, "kids_covariates.tsv"), delim='\t', covariatedf)

any(!ismissing, covariatedf.mother_HHS)
@pt covariatedf
```

Now, we'll run `Maaslin2` using `RCall.jl`.
You need to have `Maaslin2` installed for this to work - [see here](https://bitbucket.org/biobakery/maaslin2/src/default/#markdown-header-installation)

```julia; results="hidden"
using RCall

R"library(Maaslin2)"
let version = R"packageVersion('Maaslin2')"
    println(version)
end
```

```julia; results="hidden"
# Model: species abundance ~ age + mother_HHS + breastfed + birthType

R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_species_abundance.tsv")),
            $(joinpath(outpath, "kids_covariates.tsv")),
            $(joinpath(outpath, "species__age_ses_bf_birth")))
"""
```

The results from this run can be found in `data/notebooks/07/species__wm_age_ses_bf_birth/`

We can do this with brain data as well:

```julia; results="hidden"
whitematterdf = view(focusmeta, :, [:sample, :white_matter_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_white_matter.tsv"), delim='\t', whitematterdf)

# Model: species abundance ~ white_matter_volume + age + mother_HHS + breastfed + birthType
R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_species_abundance.tsv")),
            $(joinpath(outpath, "kids_white_matter.tsv")),
            $(joinpath(outpath, "species__wmNorm_age_ses_bf_birth")))
"""
```

```julia; results="hidden"
greymatterdf = view(focusmeta, :, [:sample, :grey_matter_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_grey_matter.tsv"), delim='\t', greymatterdf)

# Model: species abundance ~ grey_matter_volume + age + mother_HHS + breastfed + birthType

R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_species_abundance.tsv")),
            $(joinpath(outpath, "kids_grey_matter.tsv")),
            $(joinpath(outpath, "species__gmNorm_age_ses_bf_birth")))
"""

csfdf = view(focusmeta, :, [:sample, :csf_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_csf.tsv"), delim='\t', csfdf)

# Model: species abundance ~ csf_volume + age + mother_HHS + breastfed + birthType

R"""
fit_data <- Maaslin2(
             $(joinpath(outpath, "kids_species_abundance.tsv")),
             $(joinpath(outpath, "kids_csf.tsv")),
             $(joinpath(outpath, "species__csfNorm_age_ses_bf_birth")))
"""
```

Again, the results from these Maaslin2 runs can be found in `data/notebooks/07/`.

## Cognitive Assessments

As we did in notebook 6, we'll create a new column
that contains the age-appropriate  composite cognitive score for each kid.

```julia
# Bayleys doesn't have a composite score calculated, but we can get it:
focusmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(focusmeta))

focusmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(focusmeta,1))
focusmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(focusmeta,1))

map(enumerate(eachrow(focusmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        focusmeta[i, :cogAssessment] = assessment
        focusmeta[i, :cogScore] = cogs[col[1]]
    end
end

describe(focusmeta.cogScore)
describe(focusmeta.cogAssessment)
```

```julia
@df focusmeta scatter(:correctedAgeDays ./ 365, :cogScore,
        group = map(a-> ismissing(a) ? "Missing" : a, :cogAssessment),
        legend = :bottomright, color=color1')
title!("Cognitive Assessment Composite Scores")
xlabel!("Age (years)")
ylabel!("Composite Score")
```

```julia; echo=false; results="hidden"
savefig(joinpath(figures, "cognitive-scores.svg")); nothing # hide
# Not hidden
```

```julia; results="hidden"
cogdf = view(focusmeta, :, [:sample, :cogScore, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_cog.tsv"), delim='\t', cogdf)

R"""
Maaslin2(
     $(joinpath(outpath, "kids_species_abundance.tsv")),
     $(joinpath(outpath, "kids_cog.tsv")),
     $(joinpath(outpath, "species__cog_age_ses_bf_birth")))
"""
```
