---
title: "Notebook 8: Functional Profiles"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

Now we've been through some analyses of the taxonomic profiles,
but metagenomes *also* allow the generation of functional profiles;
that is, what genes are present in a given community.

These profiles were generated with [HUMANn2](http://huttenhower.sph.harvard.edu/humann2).

```julia; echo=false; results="hidden"
using ECHOAnalysis
using Microbiome
using BiobakeryUtils
using StatsPlots
using DataFrames
using Distances
using CSV

(outpath, figures) = notebookpaths!(8)
```

## Gene families

```julia
genefamilies = CSV.read("data/aws/joined/batch1-9_genefamilies_names_unstratified.tsv", delim='\t')
names!(genefamilies, map(n-> Symbol(resolve_sampleID(replace(String(n), "_kneaddata_Abundance-RPKs"=>"")).sample), names(genefamilies)))
# ~ 5% prevalence filter
genefamilies = genefamilies[map(row-> sum(x-> x > 0, row[Not(1)]) > 35, eachrow(genefamilies)), :]
genefamilies = abundancetable(genefamilies)
```

```julia
allsamples = resolve_sampleID.(samplenames(genefamilies))
uabt = view(genefamilies, sites=getfield.(uniquesamples(allsamples, takefirst=true), :sample))
usamples = resolve_sampleID.(samplenames(uabt))
umeta = load_metadata(datatoml, samples=usamples)

kids = view(genefamilies, sites=getfield.(
                uniquesamples(allsamples,
                samplefilter=s-> startswith(s, "C"),
                takefirst=true), :sample))
moms = view(genefamilies, sites=getfield.(
                uniquesamples(allsamples,
                samplefilter=s-> startswith(s, "M"),
                takefirst=true), :sample))

kidssamples = resolve_sampleID.(samplenames(kids))
momsamples = resolve_sampleID.(samplenames(moms))

fkidsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(kids)))
momsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(moms)))

fkids = view(genefamilies, sites=getfield.(
                uniquesamples(allsamples, [:subject],
                samplefilter=s-> startswith(s, "C"),
                takefirst=true), :sample))

fmoms = view(genefamilies, sites=getfield.(
                uniquesamples(allsamples, [:subject],
                samplefilter=s-> startswith(s, "M"),
                takefirst=true), :sample))

fkidsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(fkids)))
fmomsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(fmoms)))
```
```julia
using StatsPlots
using MultivariateStats

udm = pairwise(BrayCurtis(), uabt, dims=2)

labels = map(eachrow(umeta)) do row
    age = row[:correctedAgeDays] / 365
    if startswith(row[:sample], "C")
        if !ismissing(age)
            if age <= 1
                return "< 1 yo kid"
            elseif age <= 2
                return "1-2 yo kid"
            else
                return "> 2 yo kid"
            end
        else
            return missing
        end
    elseif startswith(row[:sample], "M")
        return "mom"
    else
        return missing
    end
end

notmissing = .!ismissing.(labels)

nmumds = fit(MDS, udm[notmissing, notmissing], distances=true)
plot(nmumds, group=String.(labels[notmissing]), legend=:topleft)
```

```julia
udm = pairwise(BrayCurtis(), uabt, dims=2)
perm = permanova(udm, [startswith(s, "M") ? "mom" : "kid" for s in samplenames(uabt)])
perm[!,:feature] .= "genefamilies"
perm[!,:variable] .= "Subject Type"
```

```julia
fkids_dm = pairwise(BrayCurtis(), fkids, dims=2)

p = permanova(fkids_dm, fkidsmeta.correctedAgeDays, filter=.!ismissing.(fkidsmeta.correctedAgeDays))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "Age"
perm = vcat(perm, p)

fkidsmeta.birthType = Vector{Union{Missing,String}}(fkidsmeta.birthType)
p = permanova(fkids_dm, fkidsmeta.birthType, filter=.!ismissing.(fkidsmeta.birthType))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "birthType"
perm = vcat(perm, p)

fkidsmeta[!, :breastfed] = breastfeeding.(eachrow(fkidsmeta))
p = permanova(fkids_dm, fkidsmeta.breastfed)
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "breastfed"
perm = vcat(perm, p)

fkidsmeta.formulafed = formulafeeding.(eachrow(fkidsmeta))
p = permanova(fkids_dm, fkidsmeta.formulafed)
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "formulafed"
perm = vcat(perm, p)

fkidsmeta.childGender = Vector{Union{Missing,String}}(fkidsmeta.childGender)
p = permanova(fkids_dm, fkidsmeta.childGender, filter=.!ismissing.(fkidsmeta.childGender))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "childGender"
perm = vcat(perm, p)

p = permanova(fkids_dm, fkidsmeta.mother_HHS, filter=.!ismissing.(fkidsmeta.mother_HHS))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "mother_HHS"
perm = vcat(perm, p);
```

```julia
using RCall

filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:white_matter_volume]), eachrow(fkidsmeta))
r_meta = fkidsmeta[filt, [:correctedAgeDays, :white_matter_volume]]
r_dm = fkids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ white_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]

p[!,:feature] .= "genefamilies"
p[!, :variable] .= "white_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## grey matter
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:grey_matter_volume]), eachrow(fkidsmeta))
r_meta = fkidsmeta[filt, [:correctedAgeDays, :grey_matter_volume]]
r_dm = fkids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ grey_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "grey_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## CSF
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:csf_volume]), eachrow(fkidsmeta))
r_meta = fkidsmeta[filt, [:correctedAgeDays, :csf_volume]]
r_dm = fkids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ csf_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "csf_volume"
perm = vcat(perm, p[[2],:])
```
```julia
## Cognitive Assessment

using Statistics
# Bayleys doesn't have a compositve score calculated, but we can get it:
fkidsmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(fkidsmeta))

fkidsmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(fkidsmeta,1))
fkidsmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(fkidsmeta,1))

map(enumerate(eachrow(fkidsmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        fkidsmeta[i, :cogAssessment] = assessment
        fkidsmeta[i, :cogScore] = cogs[col[1]]
    end
end

p = permanova(fkids_dm, fkidsmeta.cogScore, filter=.!ismissing.(fkidsmeta.cogScore))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "cogScore"
perm = vcat(perm, p);
```

```julia
ykids = view(fkids, sites=map(s-> !ismissing(s) && s < 365*2, fkidsmeta.correctedAgeDays))
ykidsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(ykids)))
ykids_dm = pairwise(BrayCurtis(), ykids)

ykidsmeta[!, :breastfed] = breastfeeding.(eachrow(ykidsmeta))
p = permanova(ykids_dm, ykidsmeta.breastfed)
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "young kids breastfed"
perm = vcat(perm, p)

ykidsmeta.formulafed = formulafeeding.(eachrow(ykidsmeta))
p = permanova(ykids_dm, ykidsmeta.formulafed)
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "young kids formulafed"
perm = vcat(perm, p)
```

```julia
okids = view(fkids, sites=map(s-> !ismissing(s) && s > 365*2, fkidsmeta.correctedAgeDays))
okidsmeta = view(fkidsmeta, map(s-> !ismissing(s) && s > 365*2, fkidsmeta.correctedAgeDays), :)
okids_dm = pairwise(BrayCurtis(), okids)

p = permanova(okids_dm, okidsmeta.cogScore, filter=.!ismissing.(okidsmeta.cogScore))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids cogScore"
perm = vcat(perm, p);

p = permanova(okids_dm, okidsmeta.csf_volume, filter=.!ismissing.(okidsmeta.csf_volume))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids csf_volume"
perm = vcat(perm, p);

p = permanova(okids_dm, okidsmeta.grey_matter_volume, filter=.!ismissing.(okidsmeta.grey_matter_volume))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids grey_matter_volume"
perm = vcat(perm, p);

p = permanova(okids_dm, okidsmeta.white_matter_volume, filter=.!ismissing.(okidsmeta.white_matter_volume))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids white_matter_volume"
perm = vcat(perm, p);
```


```julia
using MultipleTesting

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)

perm.p_value = Float64.(perm[Symbol("Pr(>F)")])
perm.q_value = adjust(perm.p_value, BenjaminiHochberg())
sort!(perm, :q_value)

# reorder columns
perm = perm[:,[:feature, :variable, :R2, :p_value, :q_value]]
CSV.write(joinpath(outpath, "genefamilies_permanovas.csv"), perm)
```

```julia
using StatsPlots

sort!(perm, [:R2])

bar(perm.R2 .* 100,
    xticks=(1:(size(perm,1)-1), perm.variable),
    xrotation=45, color=:grey)

for i in eachindex(perm.R2)
    r2 = perm[i, :R2] * 100
    q = perm[i, :q_value]
    kind = perm.variable
    if q > 0.05
        continue
    elseif q > 0.01
        stars = "*"
    elseif q > .001
        stars = "**"
    else
        stars = "***"
    end
    annotate!(i, r2+.1, text(stars, :center))
end

plot!(legend=false, title="Function Profiles (genefamilies) PERMANOVA",
    ylabel="% Variance explainable")
```

```julia
savefig(joinpath(figures, "genefamilies_permanovas.svg"))
```

## Enzyme Classes

```julia
ecs = CSV.read("data/aws/joined/batch1-9_ecs_names_unstratified.tsv", delim='\t')
names!(ecs, map(n-> Symbol(resolve_sampleID(replace(String(n), "_kneaddata_Abundance-RPKs"=>"")).sample), names(ecs)))
ecs = abundancetable(ecs)

relativeabundance!(ecs)
```

```julia
allsamples = resolve_sampleID.(samplenames(ecs))
uabt = view(ecs, sites=getfield.(uniquesamples(allsamples, takefirst=true), :sample))
usamples = resolve_sampleID.(samplenames(uabt))
umeta = load_metadata(datatoml, samples=usamples)

kids = view(ecs, sites=getfield.(
                uniquesamples(allsamples,
                samplefilter=s-> startswith(s, "C"),
                takefirst=true), :sample))
moms = view(ecs, sites=getfield.(
                uniquesamples(allsamples,
                samplefilter=s-> startswith(s, "M"),
                takefirst=true), :sample))

kidssamples = resolve_sampleID.(samplenames(kids))
momsamples = resolve_sampleID.(samplenames(moms))

fkidsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(kids)))
momsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(moms)))

fkids = view(ecs, sites=getfield.(
                uniquesamples(allsamples, [:subject],
                samplefilter=s-> startswith(s, "C"),
                takefirst=true), :sample))

fmoms = view(ecs, sites=getfield.(
                uniquesamples(allsamples, [:subject],
                samplefilter=s-> startswith(s, "M"),
                takefirst=true), :sample))

fkidsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(fkids)))
fmomsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(fmoms)))
```

### PCoAs

```julia
labels = map(eachrow(umeta)) do row
    age = row[:correctedAgeDays] / 365
    if startswith(row[:sample], "C")
        if !ismissing(age)
            if age <= 1
                return "< 1 yo kid"
            elseif age <= 2
                return "1-2 yo kid"
            else
                return "> 2 yo kid"
            end
        else
            return missing
        end
    elseif startswith(row[:sample], "M")
        return "mom"
    else
        return missing
    end
end

notmissing = .!ismissing.(labels)

nmumds = fit(MDS, udm[notmissing, notmissing], distances=true)
plot(nmumds, group=String.(labels[notmissing]), legend=:topleft)
```


### Omnibus tests


```julia
udm = pairwise(BrayCurtis(), uabt, dims=2)
perm = permanova(udm, [startswith(s, "M") ? "mom" : "kid" for s in samplenames(uabt)])
perm[!,:feature] .= "ECs"
perm[!,:variable] .= "Subject Type"
```

```julia
fkids_dm = pairwise(BrayCurtis(), fkids, dims=2)

p = permanova(fkids_dm, fkidsmeta.correctedAgeDays, filter=.!ismissing.(fkidsmeta.correctedAgeDays))
p[!,:feature] .= "ECs"
p[!, :variable] .= "Age"
perm = vcat(perm, p)

fkidsmeta.birthType = Vector{Union{Missing,String}}(fkidsmeta.birthType)
p = permanova(fkids_dm, fkidsmeta.birthType, filter=.!ismissing.(fkidsmeta.birthType))
p[!,:feature] .= "ECs"
p[!, :variable] .= "birthType"
perm = vcat(perm, p)

fkidsmeta[!, :breastfed] = breastfeeding.(eachrow(fkidsmeta))
p = permanova(fkids_dm, fkidsmeta.breastfed)
p[!,:feature] .= "ECs"
p[!, :variable] .= "breastfed"
perm = vcat(perm, p)

fkidsmeta.formulafed = formulafeeding.(eachrow(fkidsmeta))
p = permanova(fkids_dm, fkidsmeta.formulafed)
p[!,:feature] .= "ECs"
p[!, :variable] .= "formulafed"
perm = vcat(perm, p)

fkidsmeta.childGender = Vector{Union{Missing,String}}(fkidsmeta.childGender)
p = permanova(fkids_dm, fkidsmeta.childGender, filter=.!ismissing.(fkidsmeta.childGender))
p[!,:feature] .= "ECs"
p[!, :variable] .= "childGender"
perm = vcat(perm, p)

p = permanova(fkids_dm, fkidsmeta.mother_HHS, filter=.!ismissing.(fkidsmeta.mother_HHS))
p[!,:feature] .= "ECs"
p[!, :variable] .= "mother_HHS"
perm = vcat(perm, p);
```

```julia
using RCall

filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:white_matter_volume]), eachrow(fkidsmeta))
r_meta = fkidsmeta[filt, [:correctedAgeDays, :white_matter_volume]]
r_dm = fkids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ white_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]

p[!,:feature] .= "ECs"
p[!, :variable] .= "white_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## grey matter
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:grey_matter_volume]), eachrow(fkidsmeta))
r_meta = fkidsmeta[filt, [:correctedAgeDays, :grey_matter_volume]]
r_dm = fkids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ grey_matter_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "ECs"
p[!, :variable] .= "grey_matter_volume"
perm = vcat(perm, p[[2],:])
```

```julia
## CSF
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:csf_volume]), eachrow(fkidsmeta))
r_meta = fkidsmeta[filt, [:correctedAgeDays, :csf_volume]]
r_dm = fkids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ csf_volume + correctedAgeDays,
            method = "bray", data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!,:feature] .= "ECs"
p[!, :variable] .= "csf_volume"
perm = vcat(perm, p[[2],:])
```
```julia
## Cognitive Assessment

using Statistics
# Bayleys doesn't have a compositve score calculated, but we can get it:
fkidsmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(fkidsmeta))

fkidsmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(fkidsmeta,1))
fkidsmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(fkidsmeta,1))

map(enumerate(eachrow(fkidsmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        fkidsmeta[i, :cogAssessment] = assessment
        fkidsmeta[i, :cogScore] = cogs[col[1]]
    end
end

p = permanova(fkids_dm, fkidsmeta.cogScore, filter=.!ismissing.(fkidsmeta.cogScore))
p[!,:feature] .= "ECs"
p[!, :variable] .= "cogScore"
perm = vcat(perm, p);
```

```julia
ykids = view(fkids, sites=map(s-> !ismissing(s) && s < 365*2, fkidsmeta.correctedAgeDays))
ykidsmeta = load_metadata(datatoml, samples=resolve_sampleID.(samplenames(ykids)))
ykids_dm = pairwise(BrayCurtis(), ykids)

ykidsmeta[!, :breastfed] = breastfeeding.(eachrow(ykidsmeta))
p = permanova(ykids_dm, ykidsmeta.breastfed)
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "young kids breastfed"
perm = vcat(perm, p)

ykidsmeta.formulafed = formulafeeding.(eachrow(ykidsmeta))
p = permanova(ykids_dm, ykidsmeta.formulafed)
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "young kids formulafed"
perm = vcat(perm, p)
```

```julia
okids = view(fkids, sites=map(s-> !ismissing(s) && s > 365*2, fkidsmeta.correctedAgeDays))
okidsmeta = view(fkidsmeta, map(s-> !ismissing(s) && s > 365*2, fkidsmeta.correctedAgeDays), :)
okids_dm = pairwise(BrayCurtis(), okids)

p = permanova(okids_dm, okidsmeta.cogScore, filter=.!ismissing.(okidsmeta.cogScore))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids cogScore"
perm = vcat(perm, p);

p = permanova(okids_dm, okidsmeta.csf_volume, filter=.!ismissing.(okidsmeta.csf_volume))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids csf_volume"
perm = vcat(perm, p);

p = permanova(okids_dm, okidsmeta.grey_matter_volume, filter=.!ismissing.(okidsmeta.grey_matter_volume))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids grey_matter_volume"
perm = vcat(perm, p);

p = permanova(okids_dm, okidsmeta.white_matter_volume, filter=.!ismissing.(okidsmeta.white_matter_volume))
p[!,:feature] .= "genefamilies"
p[!, :variable] .= "old kids white_matter_volume"
perm = vcat(perm, p);
```


```julia
using MultipleTesting

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)

perm.p_value = Float64.(perm[Symbol("Pr(>F)")])
perm.q_value = adjust(perm.p_value, BenjaminiHochberg())
sort!(perm, :q_value)

# reorder columns
perm = perm[:,[:feature, :variable, :R2, :p_value, :q_value]]
CSV.write(joinpath(outpath, "ecs_permanovas.csv"), perm)
```

```julia
using StatsPlots

sort!(perm, [:R2])

bar(perm.R2 .* 100,
    xticks=(1:(size(perm,1)-1), perm.variable),
    xrotation=45, color=:grey)

for i in eachindex(perm.R2)
    r2 = perm[i, :R2] * 100
    q = perm[i, :q_value]
    kind = perm.variable
    if q > 0.05
        continue
    elseif q > 0.01
        stars = "*"
    elseif q > .001
        stars = "**"
    else
        stars = "***"
    end
    annotate!(i, r2+.1, text(stars, :center))
end

plot!(legend=false, title="Function Profiles (ECs) PERMANOVA",
    ylabel="% Variance explainable")
```

```julia
savefig(joinpath(figures, "ecs_permanovas.svg"))
```

### Linear Models

Because there are so many gene functions,
we'll do some agressive filtering for
prevalence and abundance.

```julia
prevfilt = let occ = occurrences(fkids)
    # at least 5% of samples have at least 0.0001% abundance
    [prevalence(occ[i, :], 1e-6) > 0.05 for i in 1:size(occ, 1)]
end

prev = view(fkids, species=prevfilt)

ecdf = DataFrame(EC=featurenames(prev))

let occ = occurrences(prev)
    for (i, sample) in enumerate(samplenames(prev))
        ismissing(fkidsmeta[i, :birthType]) && continue
        # Make a column for each sample
        ecdf[!, Symbol(sample)] = occ[:, i]
    end
end

ecdf[!,1] = map(s-> replace(s, r"[^\w]"=>"."), ecdf[!,1])
```

```julia
# add a sample id column
fkidsmeta.sample = collect(samplenames(prev))
filter!(row-> !ismissing(row[:birthType]), fkidsmeta)

# view() does not create a new dataframe, but allows us to subset it.
whitematterdf = view(fkidsmeta, :, [:sample, :white_matter_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])

# Maaslin2 also wants tab separated values
CSV.write(joinpath(outpath, "kids_ec_abundance.tsv"), delim='\t', ecdf)
CSV.write(joinpath(outpath, "kids_white_matter.tsv"), delim='\t', whitematterdf)
```

Now, we'll run Maaslin2.
You need to have Maaslin2 installed for this to work - [see here](https://bitbucket.org/biobakery/maaslin2/src/default/#markdown-header-installation)

```julia
using RCall

R"library(Maaslin2)"
let version = R"packageVersion('Maaslin2')"
    @show version
end;
```

```julia; results="hidden"
R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_ec_abundance.tsv")),
            $(joinpath(outpath, "kids_white_matter.tsv")),
            $(joinpath(outpath, "ec__wm_age_ses_bf_birth")))
"""
```

We can do this with some other brain data as well:


```julia; results="hidden"
greymatterdf = view(fkidsmeta, :, [:sample, :grey_matter_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_grey_matter.tsv"), delim='\t', greymatterdf)

R"""
fit_data <- Maaslin2(
            $(joinpath(outpath, "kids_ec_abundance.tsv")),
            $(joinpath(outpath, "kids_grey_matter.tsv")),
            $(joinpath(outpath, "ec__gm_age_ses_bf_birth")))
"""

csfdf = view(fkidsmeta, :, [:sample, :csf_volume, :correctedAgeDays, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_csf.tsv"), delim='\t', csfdf)

R"""
fit_data <- Maaslin2(
             $(joinpath(outpath, "kids_ec_abundance.tsv")),
             $(joinpath(outpath, "kids_csf.tsv")),
             $(joinpath(outpath, "ec__csf_age_ses_bf_birth")))
""";
```

#### Cognitive Assessments


```julia
# Bayleys doesn't have a compositve score calculated, but we can get it:
fkidsmeta.bayleysComposite = map(row->
    mean([row[:languageComposite], row[:motorComposite]]),
    eachrow(fkidsmeta))

fkidsmeta.cogScore = Vector{Union{Float64,Missing}}(missing, size(fkidsmeta,1))
fkidsmeta.cogAssessment = Vector{Union{String,Missing}}(missing, size(fkidsmeta,1))

map(enumerate(eachrow(fkidsmeta))) do (i, row)
    # get just the cognitive assessment columns
    cogs = row[[
                :mullen_EarlyLearningComposite,
                :fullScaleComposite, # this is from WSSPI
                :FSIQ_Composite, # this is from WISC
                :bayleysComposite
            ]]
    # if there's no score, skip row
    all(ismissing, cogs) && return
    # otherwise, get the first non-missing value (no timepoints have multiple scores)
    col = findall(!ismissing, cogs)
    let assessment = col[1]
        if assessment == :mullen_EarlyLearningComposite
            assessment = "Mullen"
        elseif assessment == :fullScaleComposite
            assessment = "WSSPI"
        elseif assessment == :FSIQ_Composite
            assessment = "WISC"
        else assessment == :bayleysComposite
            assessment = "Bayleys"
        end

        fkidsmeta[i, :cogAssessment] = assessment
        fkidsmeta[i, :cogScore] = cogs[col[1]]
    end
end
```

```julia; results="hidden"
cogdf = view(fkidsmeta, :, [:sample, :cogScore, :mother_HHS, :breastfed, :birthType])
CSV.write(joinpath(outpath, "kids_cog.tsv"), delim='\t', cogdf)

R"""
Maaslin2(
     $(joinpath(outpath, "kids_ec_abundance.tsv")),
     $(joinpath(outpath, "kids_cog.tsv")),
     $(joinpath(outpath, "ec__cog_age_ses_bf_birth")))
""";

```
